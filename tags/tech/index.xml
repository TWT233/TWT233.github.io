<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tech on Twilight Tornado</title><link>http://chiro.wang/tags/tech/</link><description>Recent content in tech on Twilight Tornado</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Wed, 09 Mar 2022 18:03:08 +0800</lastBuildDate><atom:link href="http://chiro.wang/tags/tech/index.xml" rel="self" type="application/rss+xml"/><item><title>从源码看 Go errors</title><link>http://chiro.wang/posts/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8B-go-errors/</link><pubDate>Wed, 09 Mar 2022 18:03:08 +0800</pubDate><guid>http://chiro.wang/posts/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8B-go-errors/</guid><description>go version: 1.15.7
TL;DR for usage only error 是一个 interface，只包含一个 method: Error() string，返回该 error 的信息 两种常用新建 error 的方法： errors.New() fmt.Errorf() wrap error：保留核心 error 信息，方便细粒度错误处理 wrap error 的方法： 自己实现一个包含 Unwrap() error 方法的结构 使用 fmt.Errorf() + %w 格式标记符 unwrap error：解出核心 error，透过封装看本质，进行更精细的错误处理 errors 包提供的两个函数： Is(err, target error) bool：判断 err 能否匹配 target As(err error, target interface{}) bool：如果 err 匹配 target，将匹配结果放入 target 注意：target 需要为指向 error 的指针 拓展：</description></item><item><title>从源码看 Go Context</title><link>http://chiro.wang/posts/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8B-go-context/</link><pubDate>Mon, 13 Sep 2021 15:37:54 +0800</pubDate><guid>http://chiro.wang/posts/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8B-go-context/</guid><description>最近写业务发现该来学学 go 的 context 了，拿起 gopl 来看，发现书里没讲这个包，上网搜的相关教程讲的有点怪怪的，最后还是捞出源码来看了，于是就有了这篇。
源码 https://github.com/golang/go/tree/master/src/context
文件注释 看标准库，那肯定得从注释看起。
虽然上来就看注释很可能看不懂概念，不过万事开头难嘛，没什么怕的，我们遇到新概念的时候记录一下方便后面留个心眼就行。官方的注释文档还是很有参考意义的，所以我们分段来慢慢看：
以下是源码中的文件注释的第一段，亦即摘要（L5 - L7）：
// Package context defines the Context type, which carries deadlines, // cancellation signals, and other request-scoped values across API boundaries // and between processes. 从摘要中可以看出来 context 包主要干的活儿就是定义类型 Context，这个类型里带了一些参数
注意到摘要里是这样描述参数的：request-scoped values，这个词信息量还挺大的：
这个 Context 类型是 request 相关的，所以 Context 的主要应用场景会是网络请求的收发和处理上 一个 request 应该对应一个 Context，这指导了 Context 的用法和使用时应该绑定请求，最好不要在多个请求的处理流程中复用同一个 Context 后面就是讲用法和注意事项了（L9 - L23，有点长，就不 copy docstring 过来了，这里是做个小总结，推荐大家对照着注释读）：
收到请求时要创建 Context，调用外部函数了要传 Context 过去 要维持 Context 链，这里提到了几个操作：WithCancel、WithDeadline、WithTimeout、WithValue，这几个操作可以用来制造子孙 Context，待会儿要重点看看 Context 的 Cancel 处理（Cancel 译成终止） 当一个 Context 被终止时，所有基于它生成的 Context 也会被终止 WithCancel、WithDeadline、WithTimeout 都会生成一个 CancelFunc 用来终止 Context，使用时请确保每一条控制流路径上都会调用CancelFunc（go vet 可以检查这一项的 好东西） 接下来是几条「守则」（L25 - L44），推荐大家都遵守这些守则，可以保持各个包中的接口都一致，同时也能让静态分析工具（比如后面会提到的 go vet）来分析 Context 的使用。我们来看看都有些啥：</description></item></channel></rss>