<!doctype html><html lang=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>从源码看 Go errors - Twilight Tornado</title><meta name=description content="go version: 1.15.7
TL;DR for usage only  error 是一个 interface，只包含一个 method: Error() string，返回该 error 的信息  两种常用新建 error 的方法：  errors.New() fmt.Errorf()     wrap error：保留核心 error 信息，方便细粒度错误处理  wrap error 的方法：  自己实现一个包含 Unwrap() error 方法的结构 使用 fmt.Errorf() + %w 格式标记符     unwrap error：解出核心 error，透过封装看本质，进行更精细的错误处理  errors 包提供的两个函数：  Is(err, target error) bool：判断 err 能否匹配 target As(err error, target interface{}) bool：如果 err 匹配 target，将匹配结果放入 target  注意：target 需要为指向 error 的指针        拓展："><meta name=author content><link rel="preload stylesheet" as=style href=http://chiro.wang/app.min.css><link rel="preload stylesheet" as=style href=http://chiro.wang/an-old-hope.min.css><script defer src=http://chiro.wang/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=http://chiro.wang/theme.png><link rel=preload as=image href=http://chiro.wang/twitter.svg><link rel=preload as=image href=http://chiro.wang/github.svg><link rel=icon href=http://chiro.wang/favicon.ico><link rel=apple-touch-icon href=http://chiro.wang/apple-touch-icon.png><meta name=generator content="Hugo 0.97.3"><meta property="og:title" content="从源码看 Go errors"><meta property="og:description" content="go version: 1.15.7
TL;DR for usage only  error 是一个 interface，只包含一个 method: Error() string，返回该 error 的信息  两种常用新建 error 的方法：  errors.New() fmt.Errorf()     wrap error：保留核心 error 信息，方便细粒度错误处理  wrap error 的方法：  自己实现一个包含 Unwrap() error 方法的结构 使用 fmt.Errorf() + %w 格式标记符     unwrap error：解出核心 error，透过封装看本质，进行更精细的错误处理  errors 包提供的两个函数：  Is(err, target error) bool：判断 err 能否匹配 target As(err error, target interface{}) bool：如果 err 匹配 target，将匹配结果放入 target  注意：target 需要为指向 error 的指针        拓展："><meta property="og:type" content="article"><meta property="og:url" content="http://chiro.wang/posts/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8B-go-errors/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-09T18:03:08+08:00"><meta property="article:modified_time" content="2022-03-09T18:03:08+08:00"><meta itemprop=name content="从源码看 Go errors"><meta itemprop=description content="go version: 1.15.7
TL;DR for usage only  error 是一个 interface，只包含一个 method: Error() string，返回该 error 的信息  两种常用新建 error 的方法：  errors.New() fmt.Errorf()     wrap error：保留核心 error 信息，方便细粒度错误处理  wrap error 的方法：  自己实现一个包含 Unwrap() error 方法的结构 使用 fmt.Errorf() + %w 格式标记符     unwrap error：解出核心 error，透过封装看本质，进行更精细的错误处理  errors 包提供的两个函数：  Is(err, target error) bool：判断 err 能否匹配 target As(err error, target interface{}) bool：如果 err 匹配 target，将匹配结果放入 target  注意：target 需要为指向 error 的指针        拓展："><meta itemprop=datePublished content="2022-03-09T18:03:08+08:00"><meta itemprop=dateModified content="2022-03-09T18:03:08+08:00"><meta itemprop=wordCount content="824"><meta itemprop=keywords content="tech,go,"><meta name=twitter:card content="summary"><meta name=twitter:title content="从源码看 Go errors"><meta name=twitter:description content="go version: 1.15.7
TL;DR for usage only  error 是一个 interface，只包含一个 method: Error() string，返回该 error 的信息  两种常用新建 error 的方法：  errors.New() fmt.Errorf()     wrap error：保留核心 error 信息，方便细粒度错误处理  wrap error 的方法：  自己实现一个包含 Unwrap() error 方法的结构 使用 fmt.Errorf() + %w 格式标记符     unwrap error：解出核心 error，透过封装看本质，进行更精细的错误处理  errors 包提供的两个函数：  Is(err, target error) bool：判断 err 能否匹配 target As(err error, target interface{}) bool：如果 err 匹配 target，将匹配结果放入 target  注意：target 需要为指向 error 的指针        拓展："></head><body class=not-ready data-menu=false><header class=header><p class=logo><a class=site-name href=http://chiro.wang/>Twilight Tornado</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>{bodyClx[e?"add":"remove"]("dark"),localStorage.setItem("dark",e?"yes":"no")};setDark(darkVal?darkVal==="yes":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",e=>setDark(e.matches))</script><nav class=social><a class=twitter style=--url:url(./twitter.svg) href=https://twitter.com/TWT2333 target=_blank></a>
<a class=github style=--url:url(./github.svg) href=https://github.com/TWT233 target=_blank></a></nav></header><main class=main><article class=post-single><header class=post-title><p><time>Mar 9, 2022</time></p><h1>从源码看 Go errors</h1></header><section class=post-content><p><em>go version: 1.15.7</em></p><h1 id=tldr-for-usage-only>TL;DR for usage only</h1><ul><li>error 是一个 interface，只包含一个 method: <code>Error() string</code>，返回该 error 的信息<ul><li>两种常用新建 error 的方法：<ol><li>errors.New()</li><li>fmt.Errorf()</li></ol></li></ul></li><li>wrap error：保留核心 error 信息，方便细粒度错误处理<ul><li>wrap error 的方法：<ol><li>自己实现一个包含 <code>Unwrap() error</code> 方法的结构</li><li>使用 <code>fmt.Errorf()</code> + <code>%w</code> 格式标记符</li></ol></li></ul></li><li>unwrap error：解出核心 error，透过封装看本质，进行更精细的错误处理<ul><li>errors 包提供的两个函数：<ol><li><code>Is(err, target error) bool</code>：判断 err 能否匹配 target</li><li><code>As(err error, target interface{}) bool</code>：如果 err 匹配 target，将匹配结果放入 target<ul><li>注意：target 需要为指向 error 的指针</li></ul></li></ol></li></ul></li></ul><p>拓展：</p><p><a href=#%E6%8B%93%E5%B1%95%EF%BC%9Agithub.com/pkg/errors>推荐包：<code>github.com/pkg/errors</code></a></p><p>接口语义自然、用法简洁，支持更多功能（如为 error 打印栈、try-catch style error handling）</p><hr><p>这是一个很短小精悍的包，提供了操作 error 的接口，日常使用中经常会用到</p><h1 id=interface-error>interface: error</h1><p>需要先说的是 error，这是 errors 包的中心</p><p>error 是一个 interface，只包含一个 method: <code>Error() string</code>，返回该 error 的信息</p><h1 id=errorsgo>errors.go</h1><p>errors.go 东西很少：一个 func 和一个 struct</p><h2 id=new>New()</h2><p><code>New</code> 很简单：返回一个 <code>errorString</code></p><h2 id=errorstring>errorString</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// errorString is a trivial implementation of error.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>errorString</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>errorString</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到 errorString 就只包含一个 string 用来保存 <code>Error()</code> 需要的信息</p><h1 id=wrapgo>wrap.go</h1><p>wrap.go 顾名思义，用来处理 error wrap 的 func 都放在这里了</p><h2 id=什么是-error-wrap--为什么要用它>什么是 error wrap & 为什么要用它</h2><p>go 中的异常处理对象都是基于 error interface 进行的，
而这个 interface 只有一个 <code>Error()</code>，
这就导致处理的粒度很粗：</p><ol><li>很多情况下你只能知道 <code>err != nil</code>，而不知道这个 err 具体是什么类型的错误</li><li>如果你想知道这个 err 的具体类型，就需要解析 <code>err.Error()</code> 了</li><li>而 <code>err.Error()</code> 是个字符串，手工解析字符串比较折磨、也很不优雅、还很容易坏</li></ol><p>所以 error wrap 就来了，error wrap 可以保留核心 error，方便错误处理</p><p>使用这个机制可以封装（wrap）一个 error，而后可以通过拆包（unwrap）把内部的 error 拆出来</p><h2 id=error-wrap-使用--实现>error wrap 使用 & 实现</h2><h3 id=怎么-wrap-一个-error>怎么 wrap 一个 error</h3><p>见 errors.go#L10-L14:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// An error wraps another error if its type has the method
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>//	Unwrap() error
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If e.Unwrap() returns a non-nil error w, then we say that e wraps w.
</span></span></span></code></pre></div><p>所以我们只需要实现一个 struct，包含一个 <code>Unwrap() error</code> 方法就可以</p><p>这个 <code>Unwrap()</code> 方法在语义上应该遵循：返回的是内部被 wrap 的 error</p><p>官方库中的例子（来自 <code>fmt/errors.go#L32-L41</code>）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>wrapError</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>msg</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>wrapError</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>msg</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>wrapError</span>) <span style=color:#a6e22e>Unwrap</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>msg 用于实现 <code>error.Error()</code>，err 用以实现 <code>error.Unwrap()</code>，很简洁方便</p><p>但是每次都自己写一个 struct 也挺难过的，Go 标准库也提供了相关的支持，就是刚刚提到的 fmt 包：</p><p>errors.go#L19-L24</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// A simple way to create wrapped errors is to call fmt.Errorf and apply the %w verb
</span></span></span><span style=display:flex><span><span style=color:#75715e>// to the error argument:
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>//	errors.Unwrap(fmt.Errorf(&#34;... %w ...&#34;, ..., err, ...))
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// returns err.
</span></span></span></code></pre></div><p>调用 <code>fmt.Errorf()</code> 时将插值 err 的格式标记符（verb/format specifier）换成 <code>%w</code> 即可</p><p><em>题外话：大家在还没用上%w 的时候一般用什么？我一般用%v/%+v</em></p><h3 id=wrap-之后怎么用>wrap 之后怎么用</h3><p>wrap 是为了让我们能方便地获取内部的 error 类型以进行更细粒度的错误处理，那么怎么来处理呢？</p><h4 id=is>Is()</h4><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>myOpen</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Is</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>ErrNotExist</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// an ErrNotExist, handle stuff here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Is</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>ErrInvalid</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// an ErrInvalid, handle stuff here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;unable to cover error: &#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;myOpen&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p><code>func Is(err, target error) bool</code> 用以判断 err 层层 unwrap（像洋葱一样）之后能否匹配到 target</p><p><code>Is()</code> 也和很多库一样，优先支持自定义的 <code>Is()</code> 方法覆写行为：</p><p>如果 unwrap err 的过程中，遇到一个 err 自定义了 <code>Is()</code> 方法，那就优先用该自定义的方法</p><p>实现源码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Is</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>target</span> <span style=color:#66d9ef>error</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>target</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>isComparable</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflectlite</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>target</span>).<span style=color:#a6e22e>Comparable</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isComparable</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>target</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>err</span>.(<span style=color:#66d9ef>interface</span>{ <span style=color:#a6e22e>Is</span>(<span style=color:#66d9ef>error</span>) <span style=color:#66d9ef>bool</span> }); <span style=color:#a6e22e>ok</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>Is</span>(<span style=color:#a6e22e>target</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// TODO: consider supporting target.Is(err). This would allow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// user-definable predicates, but also may allow for coping with sloppy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// APIs, thereby making it easier to get away with them.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>Unwrap</span>(<span style=color:#a6e22e>err</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>流程：</p><ol><li>2-4: 入参检查、快速返回</li><li>6: 用反射检查 target 是不是 Comparable（能直接比较，能作为 ==、!= 的操作数）</li><li>进入剥洋葱比较循环<ol><li>1-3: 如果 target 能直接比较就直接比、匹配成功快速返回</li><li>4-6: target 不能直接比，看看当前洋葱有没有自定义 <code>Is()</code>，有的话就用，匹配成功快速返回</li><li>10-12: 再剥一层洋葱，要是剥没了就返回 false</li></ol></li></ol><p>这也指导我们平时固化错误时有两种推荐做法：</p><ol><li>做成 Comparable 的（不包含 map/slice/func）<ol><li>比如常用的<code>var ErrKey = fmt.Error("errKey")</code></li></ol></li><li>做一层封装，封装实现 <code>Is(error) bool</code><ol><li>要是想在 error 里带动态信息以方便处理的话推荐做这个</li></ol></li></ol><h4 id=as>As()</h4><p><code>As()</code> 是 <code>Is()</code> 的拓展：不仅会匹配 err 与 target，而且匹配成功时会把匹配结果放到 target 里</p><p>这也对 target 提出了要求：</p><ol><li>非 nil</li><li>是个指针</li><li>*target 是 interface 或者实现了 error</li></ol><p>例子（来自<a href=https://go.dev/blog/go1.13-errors>官方 blog</a>）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Similar to:
</span></span></span><span style=display:flex><span><span style=color:#75715e>//   if e, ok := err.(*QueryError); ok { … }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>QueryError</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Note: *QueryError is the type of the error.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>As</span>(<span style=color:#a6e22e>err</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// err is a *QueryError, and e is set to the error&#39;s value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>实现源码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>As</span>(<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>, <span style=color:#a6e22e>target</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;errors: target cannot be nil&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflectlite</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>target</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>typ</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>val</span>.<span style=color:#a6e22e>Type</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>typ</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflectlite</span>.<span style=color:#a6e22e>Ptr</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>val</span>.<span style=color:#a6e22e>IsNil</span>() {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;errors: target must be a non-nil pointer&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typ</span>.<span style=color:#a6e22e>Elem</span>(); <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflectlite</span>.<span style=color:#a6e22e>Interface</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>errorType</span>) {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;errors: *target must be interface or implement error&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>targetType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typ</span>.<span style=color:#a6e22e>Elem</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>reflectlite</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>err</span>).<span style=color:#a6e22e>AssignableTo</span>(<span style=color:#a6e22e>targetType</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>val</span>.<span style=color:#a6e22e>Elem</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>reflectlite</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>err</span>))
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>err</span>.(<span style=color:#66d9ef>interface</span>{ <span style=color:#a6e22e>As</span>(<span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>bool</span> }); <span style=color:#a6e22e>ok</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>As</span>(<span style=color:#a6e22e>target</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>Unwrap</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>流程：</p><ol><li>检查非 nil</li><li>检查为指针且非 nil</li><li>检查*target 是 interface 或</li><li>进入剥洋葱比较循环<ol><li>检查当前 err 能不能放进 target，能就 set 后快速返回</li><li>检查当前 err 有没有自定义 <code>As()</code>，有的话就调用，set 后快速返回</li><li>剥一层洋葱</li></ol></li></ol><h1 id=拓展githubcompkgerrors>拓展：github.com/pkg/errors</h1><p>这个包很好用，推荐一手，接口语义自然、用法简洁，我现在基本不用 <code>fmt.Errorf()</code> 了</p><h2 id=wrap-error>wrap error</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;foo&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// equals to fmt.Errorf(&#34;foo: %w&#34;, err)
</span></span></span></code></pre></div><p>且 err 为 nil 时 <code>errors.Wrap()</code> 也返回 nil，所以部分场景下代码能简洁很多：</p><p>原来的大众写法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>foo</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;foo: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span></code></pre></div><p>换用 errors 的等效写法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>foo</span>(), <span style=color:#e6db74>&#34;foo&#34;</span>)
</span></span></code></pre></div><h2 id=更自然的错误处理>更自然的错误处理</h2><p>这个包还提供了一个非常类似 try-catch 机制的接口，看例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Cause</span>(<span style=color:#a6e22e>err</span>).(<span style=color:#66d9ef>type</span>) {
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyError1</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e>// handle specifically
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyError2</span>:
</span></span><span style=display:flex><span>		<span style=color:#75715e>// handle specifically
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e>// unknown error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>用 <code>Is()</code> 来做的话需要这么写：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>myErr1</span> <span style=color:#a6e22e>MyError1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>myErr2</span> <span style=color:#a6e22e>MyError2</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>As</span>(<span style=color:#a6e22e>err</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>myErr1</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// handle specifically
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>As</span>(<span style=color:#a6e22e>err</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>myErr2</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// handle specifically
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>// unknown error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>如果习惯其他语言中 try-catch work flow 的话应该会很亲切</p><p>不过 try-catch 也常被人诟病容易滥用，所以大家根据自己和项目的习惯来选择就好</p><h2 id=打印栈>打印栈</h2><p>如果 err 递归返回的一路上都用的是 errors.Wrap，就可以打印从 err raise 到当前的栈</p><p>一是栈的排版方便看（从一把 log 里面抓一行超长的 error 的经历想必大家都体验过），
二是配合 IDE/编辑器内置的终端可以快速跳转，
还是很方便的</p><p>示例代码有点长：
<a href=https://pkg.go.dev/github.com/pkg/errors#hdr-Retrieving_the_stack_trace_of_an_error_or_wrapper>https://pkg.go.dev/github.com/pkg/errors#hdr-Retrieving_the_stack_trace_of_an_error_or_wrapper</a></p></section><footer class=post-tags><a href=http://chiro.wang/tags/tech>tech</a>
<a href=http://chiro.wang/tags/go>go</a></footer><nav class=post-nav><a class=prev href=http://chiro.wang/posts/kicad%E5%92%8Cad/><span>←</span><span>KiCad 和 Altium Designer</span></a>
<a class=next href=http://chiro.wang/posts/vim-hax-note/><span>Vim Hax Note</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2022 <a href=http://chiro.wang/>Twilight Tornado</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>