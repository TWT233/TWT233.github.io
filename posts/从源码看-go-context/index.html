<!doctype html><html lang=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>从源码看 Go Context - Twilight Tornado</title><meta name=description content="最近写业务发现该来学学 go 的 context 了，拿起 gopl 来看，发现书里没讲这个包，上网搜的相关教程讲的有点怪怪的，最后还是捞出源码来看了，于是就有了这篇。
源码 https://github.com/golang/go/tree/master/src/context
文件注释 看标准库，那肯定得从注释看起。
虽然上来就看注释很可能看不懂概念，不过万事开头难嘛，没什么怕的，我们遇到新概念的时候记录一下方便后面留个心眼就行。官方的注释文档还是很有参考意义的，所以我们分段来慢慢看：
以下是源码中的文件注释的第一段，亦即摘要（L5 - L7）：
// Package context defines the Context type, which carries deadlines, // cancellation signals, and other request-scoped values across API boundaries // and between processes. 从摘要中可以看出来 context 包主要干的活儿就是定义类型 Context，这个类型里带了一些参数
注意到摘要里是这样描述参数的：request-scoped values，这个词信息量还挺大的：
 这个 Context 类型是 request 相关的，所以 Context 的主要应用场景会是网络请求的收发和处理上 一个 request 应该对应一个 Context，这指导了 Context 的用法和使用时应该绑定请求，最好不要在多个请求的处理流程中复用同一个 Context  后面就是讲用法和注意事项了（L9 - L23，有点长，就不 copy docstring 过来了，这里是做个小总结，推荐大家对照着注释读）：
 收到请求时要创建 Context，调用外部函数了要传 Context 过去 要维持 Context 链，这里提到了几个操作：WithCancel、WithDeadline、WithTimeout、WithValue，这几个操作可以用来制造子孙 Context，待会儿要重点看看 Context 的 Cancel 处理（Cancel 译成终止）  当一个 Context 被终止时，所有基于它生成的 Context 也会被终止 WithCancel、WithDeadline、WithTimeout 都会生成一个 CancelFunc 用来终止 Context，使用时请确保每一条控制流路径上都会调用CancelFunc（go vet 可以检查这一项的 好东西）    接下来是几条「守则」（L25 - L44），推荐大家都遵守这些守则，可以保持各个包中的接口都一致，同时也能让静态分析工具（比如后面会提到的 go vet）来分析 Context 的使用。我们来看看都有些啥："><meta name=author content><link rel="preload stylesheet" as=style href=http://chiro.wang/app.min.css><link rel="preload stylesheet" as=style href=http://chiro.wang/an-old-hope.min.css><script defer src=http://chiro.wang/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=http://chiro.wang/theme.png><link rel=preload as=image href=http://chiro.wang/twitter.svg><link rel=preload as=image href=http://chiro.wang/github.svg><link rel=icon href=http://chiro.wang/favicon.ico><link rel=apple-touch-icon href=http://chiro.wang/apple-touch-icon.png><meta name=generator content="Hugo 0.94.2"><meta property="og:title" content="从源码看 Go Context"><meta property="og:description" content="最近写业务发现该来学学 go 的 context 了，拿起 gopl 来看，发现书里没讲这个包，上网搜的相关教程讲的有点怪怪的，最后还是捞出源码来看了，于是就有了这篇。
源码 https://github.com/golang/go/tree/master/src/context
文件注释 看标准库，那肯定得从注释看起。
虽然上来就看注释很可能看不懂概念，不过万事开头难嘛，没什么怕的，我们遇到新概念的时候记录一下方便后面留个心眼就行。官方的注释文档还是很有参考意义的，所以我们分段来慢慢看：
以下是源码中的文件注释的第一段，亦即摘要（L5 - L7）：
// Package context defines the Context type, which carries deadlines, // cancellation signals, and other request-scoped values across API boundaries // and between processes. 从摘要中可以看出来 context 包主要干的活儿就是定义类型 Context，这个类型里带了一些参数
注意到摘要里是这样描述参数的：request-scoped values，这个词信息量还挺大的：
 这个 Context 类型是 request 相关的，所以 Context 的主要应用场景会是网络请求的收发和处理上 一个 request 应该对应一个 Context，这指导了 Context 的用法和使用时应该绑定请求，最好不要在多个请求的处理流程中复用同一个 Context  后面就是讲用法和注意事项了（L9 - L23，有点长，就不 copy docstring 过来了，这里是做个小总结，推荐大家对照着注释读）：
 收到请求时要创建 Context，调用外部函数了要传 Context 过去 要维持 Context 链，这里提到了几个操作：WithCancel、WithDeadline、WithTimeout、WithValue，这几个操作可以用来制造子孙 Context，待会儿要重点看看 Context 的 Cancel 处理（Cancel 译成终止）  当一个 Context 被终止时，所有基于它生成的 Context 也会被终止 WithCancel、WithDeadline、WithTimeout 都会生成一个 CancelFunc 用来终止 Context，使用时请确保每一条控制流路径上都会调用CancelFunc（go vet 可以检查这一项的 好东西）    接下来是几条「守则」（L25 - L44），推荐大家都遵守这些守则，可以保持各个包中的接口都一致，同时也能让静态分析工具（比如后面会提到的 go vet）来分析 Context 的使用。我们来看看都有些啥："><meta property="og:type" content="article"><meta property="og:url" content="http://chiro.wang/posts/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8B-go-context/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-13T15:37:54+08:00"><meta property="article:modified_time" content="2021-09-13T15:37:54+08:00"><meta itemprop=name content="从源码看 Go Context"><meta itemprop=description content="最近写业务发现该来学学 go 的 context 了，拿起 gopl 来看，发现书里没讲这个包，上网搜的相关教程讲的有点怪怪的，最后还是捞出源码来看了，于是就有了这篇。
源码 https://github.com/golang/go/tree/master/src/context
文件注释 看标准库，那肯定得从注释看起。
虽然上来就看注释很可能看不懂概念，不过万事开头难嘛，没什么怕的，我们遇到新概念的时候记录一下方便后面留个心眼就行。官方的注释文档还是很有参考意义的，所以我们分段来慢慢看：
以下是源码中的文件注释的第一段，亦即摘要（L5 - L7）：
// Package context defines the Context type, which carries deadlines, // cancellation signals, and other request-scoped values across API boundaries // and between processes. 从摘要中可以看出来 context 包主要干的活儿就是定义类型 Context，这个类型里带了一些参数
注意到摘要里是这样描述参数的：request-scoped values，这个词信息量还挺大的：
 这个 Context 类型是 request 相关的，所以 Context 的主要应用场景会是网络请求的收发和处理上 一个 request 应该对应一个 Context，这指导了 Context 的用法和使用时应该绑定请求，最好不要在多个请求的处理流程中复用同一个 Context  后面就是讲用法和注意事项了（L9 - L23，有点长，就不 copy docstring 过来了，这里是做个小总结，推荐大家对照着注释读）：
 收到请求时要创建 Context，调用外部函数了要传 Context 过去 要维持 Context 链，这里提到了几个操作：WithCancel、WithDeadline、WithTimeout、WithValue，这几个操作可以用来制造子孙 Context，待会儿要重点看看 Context 的 Cancel 处理（Cancel 译成终止）  当一个 Context 被终止时，所有基于它生成的 Context 也会被终止 WithCancel、WithDeadline、WithTimeout 都会生成一个 CancelFunc 用来终止 Context，使用时请确保每一条控制流路径上都会调用CancelFunc（go vet 可以检查这一项的 好东西）    接下来是几条「守则」（L25 - L44），推荐大家都遵守这些守则，可以保持各个包中的接口都一致，同时也能让静态分析工具（比如后面会提到的 go vet）来分析 Context 的使用。我们来看看都有些啥："><meta itemprop=datePublished content="2021-09-13T15:37:54+08:00"><meta itemprop=dateModified content="2021-09-13T15:37:54+08:00"><meta itemprop=wordCount content="1323"><meta itemprop=keywords content="tech,go,"><meta name=twitter:card content="summary"><meta name=twitter:title content="从源码看 Go Context"><meta name=twitter:description content="最近写业务发现该来学学 go 的 context 了，拿起 gopl 来看，发现书里没讲这个包，上网搜的相关教程讲的有点怪怪的，最后还是捞出源码来看了，于是就有了这篇。
源码 https://github.com/golang/go/tree/master/src/context
文件注释 看标准库，那肯定得从注释看起。
虽然上来就看注释很可能看不懂概念，不过万事开头难嘛，没什么怕的，我们遇到新概念的时候记录一下方便后面留个心眼就行。官方的注释文档还是很有参考意义的，所以我们分段来慢慢看：
以下是源码中的文件注释的第一段，亦即摘要（L5 - L7）：
// Package context defines the Context type, which carries deadlines, // cancellation signals, and other request-scoped values across API boundaries // and between processes. 从摘要中可以看出来 context 包主要干的活儿就是定义类型 Context，这个类型里带了一些参数
注意到摘要里是这样描述参数的：request-scoped values，这个词信息量还挺大的：
 这个 Context 类型是 request 相关的，所以 Context 的主要应用场景会是网络请求的收发和处理上 一个 request 应该对应一个 Context，这指导了 Context 的用法和使用时应该绑定请求，最好不要在多个请求的处理流程中复用同一个 Context  后面就是讲用法和注意事项了（L9 - L23，有点长，就不 copy docstring 过来了，这里是做个小总结，推荐大家对照着注释读）：
 收到请求时要创建 Context，调用外部函数了要传 Context 过去 要维持 Context 链，这里提到了几个操作：WithCancel、WithDeadline、WithTimeout、WithValue，这几个操作可以用来制造子孙 Context，待会儿要重点看看 Context 的 Cancel 处理（Cancel 译成终止）  当一个 Context 被终止时，所有基于它生成的 Context 也会被终止 WithCancel、WithDeadline、WithTimeout 都会生成一个 CancelFunc 用来终止 Context，使用时请确保每一条控制流路径上都会调用CancelFunc（go vet 可以检查这一项的 好东西）    接下来是几条「守则」（L25 - L44），推荐大家都遵守这些守则，可以保持各个包中的接口都一致，同时也能让静态分析工具（比如后面会提到的 go vet）来分析 Context 的使用。我们来看看都有些啥："></head><body class=not-ready data-menu=false><header class=header><p class=logo><a class=site-name href=http://chiro.wang/>Twilight Tornado</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>{bodyClx[e?"add":"remove"]("dark"),localStorage.setItem("dark",e?"yes":"no")};setDark(darkVal?darkVal==="yes":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",e=>setDark(e.matches))</script><nav class=social><a class=twitter style=--url:url(./twitter.svg) href=https://twitter.com/TWT2333 target=_blank></a>
<a class=github style=--url:url(./github.svg) href=https://github.com/TWT233 target=_blank></a></nav></header><main class=main><article class=post-single><header class=post-title><p><time>Sep 13, 2021</time></p><h1>从源码看 Go Context</h1></header><section class=post-content><p>最近写业务发现该来学学 go 的 context 了，拿起 gopl 来看，发现书里没讲这个包，上网搜的相关教程讲的有点怪怪的，最后还是捞出源码来看了，于是就有了这篇。</p><h1 id=源码>源码</h1><p><a href=https://github.com/golang/go/tree/master/src/context>https://github.com/golang/go/tree/master/src/context</a></p><h1 id=文件注释>文件注释</h1><p>看标准库，那肯定得从注释看起。</p><p>虽然上来就看注释很可能看不懂概念，不过万事开头难嘛，没什么怕的，我们遇到新概念的时候记录一下方便后面留个心眼就行。官方的注释文档还是很有参考意义的，所以我们分段来慢慢看：</p><p>以下是源码中的文件注释的第一段，亦即摘要（L5 - L7）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Package context defines the Context type, which carries deadlines,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// cancellation signals, and other request-scoped values across API boundaries
</span></span></span><span style=display:flex><span><span style=color:#75715e>// and between processes.
</span></span></span></code></pre></div><p>从摘要中可以看出来 context 包主要干的活儿就是定义类型 Context，这个类型里带了一些参数</p><p>注意到摘要里是这样描述参数的：request-scoped values，这个词信息量还挺大的：</p><ol><li>这个 Context 类型是 request 相关的，所以 Context 的主要应用场景会是网络请求的收发和处理上</li><li>一个 request 应该对应一个 Context，这指导了 Context 的用法和使用时应该绑定请求，最好不要在多个请求的处理流程中复用同一个 Context</li></ol><p>后面就是讲用法和注意事项了（L9 - L23，有点长，就不 copy docstring 过来了，这里是做个小总结，推荐大家对照着注释读）：</p><ol><li>收到请求时要创建 Context，调用外部函数了要传 Context 过去</li><li>要维持 Context 链，这里提到了几个操作：<code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code>、<code>WithValue</code>，这几个操作可以用来制造子孙 Context，待会儿要重点看看</li><li>Context 的 Cancel 处理（Cancel 译成终止）<ol><li>当一个 Context 被终止时，所有基于它生成的 Context 也会被终止</li><li><code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code> 都会生成一个 <code>CancelFunc</code> 用来终止 Context，使用时请确保每一条控制流路径上都会调用<code>CancelFunc</code>（go vet 可以检查这一项的 好东西）</li></ol></li></ol><p>接下来是几条「守则」（L25 - L44），推荐大家都遵守这些守则，可以保持各个包中的接口都一致，同时也能让静态分析工具（比如后面会提到的 go vet）来分析 Context 的使用。我们来看看都有些啥：</p><ol><li>不要把 Context 放在结构体里传<ol><li>Context 应该作为参数传递</li><li>Context 还应该作为函数的第一个参数</li><li>推荐把这个参数命名为 ctx</li></ol></li><li>不要用 nil Context<ol><li>有的函数能接受 nil Context，但是还是不要用</li><li>如果不知道用什么 Context 的话就用 <code>context.TODO()</code></li><li>这儿出现了 <code>.TODO()</code>，这个名字有点怪怪的，之后我们也会重点讲讲它，<code>TODO()</code> 是个很灵性的设计</li></ol></li><li>Context 中有个概念叫 Value，不要把 Value 当作传参工具，Value 应该用来传跨 API 和进程的数据</li><li>Context 是并发安全的</li></ol><h1 id=接口声明>接口声明</h1><p>包注释结束后，<code>type Context interface{</code>就来了，开门见山。Context 统一地约束了上下文的功能，向外提供了四个方法：</p><ol><li><code>Deadline() (deadline time.Time, ok bool)</code><ul><li>超时控制相关</li><li><code>deadline</code> 是该 Context 被终止的时刻</li><li>如果还没设置终止时刻的话，<code>ok == false</code></li><li>成功调用 <code>Deadline</code> 的返回都是相同的（幂等性）</li></ul></li><li><code>Done() &lt;-chan struct{}</code><ul><li>当该 Context 被终止时，<code>Done()</code> 也会被关闭</li><li><code>Done() == nil</code> 说明该 Context 不能被终止</li><li>该方法也具有幂等性</li><li>一般结合 <code>select</code> 使用，如：</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li><code>Err() error</code><ul><li>如果 <code>Done()</code> 还没被关闭，<code>Err() == nil</code></li><li>如果 <code>Done()</code> 被关闭了，<code>Err</code> 返回一个 <code>error</code> 解释终止的原因<ul><li>返回 <code>Canceled</code> 说明是被手动终止的</li><li>返回 <code>DeadlineExceeded</code> 说明是超时终止的</li></ul></li><li>这个方法也具有幂等性</li></ul></li><li><code>Value(key interface{}) interface{}</code><ul><li><code>Value</code> 返回该 Context 中与 <code>key</code> 关联的 <code>value</code><ul><li>如果该 Context 中 <code>key</code> 没有关联 <code>value</code>，就会返回 <code>nil</code></li></ul></li><li>这个方法也具有幂等性</li></ul></li></ol><h1 id=具体实现>具体实现</h1><h2 id=error-的声明与实现>error 的声明与实现</h2><p>声明完 <code>Context</code> 接口，接着就是 <code>error</code> 的声明：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Canceled is the error returned by Context.Err when the context is canceled.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>Canceled</span> = <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;context canceled&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// DeadlineExceeded is the error returned by Context.Err when the context&#39;s
</span></span></span><span style=display:flex><span><span style=color:#75715e>// deadline passes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>DeadlineExceeded</span> <span style=color:#66d9ef>error</span> = <span style=color:#a6e22e>deadlineExceededError</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>deadlineExceededError</span> <span style=color:#66d9ef>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>deadlineExceededError</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span>   { <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;context deadline exceeded&#34;</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>deadlineExceededError</span>) <span style=color:#a6e22e>Timeout</span>() <span style=color:#66d9ef>bool</span>   { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>deadlineExceededError</span>) <span style=color:#a6e22e>Temporary</span>() <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span> }
</span></span></code></pre></div><p>在看 <code>Context.Err</code> 的注释时，我还以为 <code>Canceled</code> 和 <code>DeadlineExceeded</code> 是 <code>type</code>，用的时候再初始化，看了实现才知道是用默认对象的方法来做的</p><p>go 的标准库中有很多功能都是通过默认值/默认实现来提供的，而我以前写其他语言的代码时就比较少接触这种模式，这也算一种特色吧，要学习一下</p><p>另：context 包这个排布方法比较反我的个人直觉，我目前想到的原因：</p><ol><li>在 <code>Context.Err</code> 的注释中提到了 <code>error</code>，所以按就近原则要前置</li><li>这两个 <code>error</code> 是用默认值实现的，算常量，应该前置</li></ol><h2 id=emptyctx-起源>emptyCtx: 起源</h2><p>这是最基础的 Context：不会被终止、不能携带 value、没有 deadline，emptyCtx 的声明：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// An emptyCtx is never canceled, has no values, and has no deadline. It is not
</span></span></span><span style=display:flex><span><span style=color:#75715e>// struct{}, since vars of this type must have distinct addresses.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>emptyCtx</span> <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><p>底层使用 int 作为占位符，接口使用空实现来提供，</p><p>包中定义了两个常量 emptyCtx：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>background</span> = new(<span style=color:#a6e22e>emptyCtx</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>todo</span>       = new(<span style=color:#a6e22e>emptyCtx</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Background returns a non-nil, empty Context. It is never canceled, has no
</span></span></span><span style=display:flex><span><span style=color:#75715e>// values, and has no deadline. It is typically used by the main function,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// initialization, and tests, and as the top-level Context for incoming
</span></span></span><span style=display:flex><span><span style=color:#75715e>// requests.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Background</span>() <span style=color:#a6e22e>Context</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>background</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// TODO returns a non-nil, empty Context. Code should use context.TODO when
</span></span></span><span style=display:flex><span><span style=color:#75715e>// it&#39;s unclear which Context to use or it is not yet available (because the
</span></span></span><span style=display:flex><span><span style=color:#75715e>// surrounding function has not yet been extended to accept a Context
</span></span></span><span style=display:flex><span><span style=color:#75715e>// parameter).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TODO</span>() <span style=color:#a6e22e>Context</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>todo</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>又是默认对象实现方法，这两个 context 的使用场景也在注释中给出，可谓是万物之源</p><h3 id=问题>问题</h3><ul><li>为什么要分成两个 context，background 表达能力不足吗<ul><li>自答：background 是所有 context 之根，所以使用情景也很单一：main 线程中，其他情况下要创建新的 context 树都使用<code>TODO()</code></li><li>如果只用 background 的话，context 树就可能出现环了</li></ul></li></ul><h2 id=withcancel第一步>WithCancel()：第一步</h2><p>WithCancel 接受一个 parent context，返回一个 child context 和一个 CancelFunc，调用该 CancelFunc 就可以终止 child</p><p>这是我们接触到的第一个派生新 context 的函数。WithCancel 让我们能够手动控制一个 context 的终止</p><h3 id=cancelfunc>CancelFunc</h3><p>先来看看这个 WithCancel 给我们的榔头怎么用和长啥样，CancelFunc 的注释与 typedef 如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// A CancelFunc tells an operation to abandon its work.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A CancelFunc does not wait for the work to stop.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A CancelFunc may be called by multiple goroutines simultaneously.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// After the first call, subsequent calls to a CancelFunc do nothing.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CancelFunc</span> <span style=color:#66d9ef>func</span>()
</span></span></code></pre></div><ol><li>CancelFunc 是用来通知下游该收手了</li><li>CancelFunc 即调即起效（当然也需要下游适配）</li><li>CancelFunc 也是并发安全的、幂等的</li></ol><h3 id=内部实现>内部实现</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithCancel</span>(<span style=color:#a6e22e>parent</span> <span style=color:#a6e22e>Context</span>) (<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#a6e22e>CancelFunc</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>parent</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;cannot create context from nil parent&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newCancelCtx</span>(<span style=color:#a6e22e>parent</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>propagateCancel</span>(<span style=color:#a6e22e>parent</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>Canceled</span>) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可见逻辑非常简单：</p><ol><li>检查入参</li><li>在 parent 上挂一个新的 child context</li><li><code>propagateCancel</code> 对 parent 和 child 进行设置，使得 parent 被终止时同步终止 child<ul><li>回想：context 是树形结构排布的</li></ul></li><li>使用闭包做出 CancelFunc 并返回<ul><li>注意：这个 CancelFunc 是用以终止 child 的</li></ul></li></ol><h2 id=propagatecancel>propagateCancel</h2><p>这个函数用来设置终止操作的传播关系，使得「当一个 Context 被终止时，所有基于它生成的 Context 也会被终止」这条性质得以成立</p><p>源码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// propagateCancel arranges for child to be canceled when parent is.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>propagateCancel</span>(<span style=color:#a6e22e>parent</span> <span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>child</span> <span style=color:#a6e22e>canceler</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>parent</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>done</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#75715e>// parent is never canceled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>:
</span></span><span style=display:flex><span>		<span style=color:#75715e>// parent is already canceled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>parent</span>.<span style=color:#a6e22e>Err</span>())
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>parentCancelCtx</span>(<span style=color:#a6e22e>parent</span>); <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// parent has already been canceled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>children</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>children</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>canceler</span>]<span style=color:#66d9ef>struct</span>{})
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>children</span>[<span style=color:#a6e22e>child</span>] = <span style=color:#66d9ef>struct</span>{}{}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>goroutines</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>parent</span>.<span style=color:#a6e22e>Done</span>():
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>parent</span>.<span style=color:#a6e22e>Err</span>())
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>Done</span>():
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>流程如下，大家可以对照着理解：</p><ol><li>检查入参（包括检查 parent 是否已经被终止）</li><li>获取 parent 内部的 cancelCtx 用以注册终止事件调用链<ul><li>当 p 被终止时，会递归地终止 p.children</li></ul></li><li>如果 parent 不是一个 cancelCtx，那么就手动开一个 goro 监听 parent 的终止事件（终止信号是 parent.Done()被 closed）</li></ol><p>在<code>parentCancelCtx</code>中，有一个出于兼容性考量的设计：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// checking whether
</span></span></span><span style=display:flex><span><span style=color:#75715e>// parent.Done() matches that *cancelCtx. (If not, the *cancelCtx
</span></span></span><span style=display:flex><span><span style=color:#75715e>// has been wrapped in a custom implementation providing a
</span></span></span><span style=display:flex><span><span style=color:#75715e>// different done channel, in which case we should not bypass it.)
</span></span></span></code></pre></div><blockquote><p>来源于<code>parentCancelCtx</code>的注释</p></blockquote><p>在拿到 parent 的 cancelCtx 后，为了避免用户自定义了 Done channel 的实现导致我们「终止错了」context，所以此处还检查了<code>parent.Done()==parent.cancelCtx.done</code></p><p>这个设计还体现了「接口为本」：具体实现（parent.cancelCtx.done）和接口实现（parent.Done()）出现了冲突，以 parent.Done() 为准（抛到外面手动开一个 goro 监听 parent.Done() 被 close 的事件）</p><h2 id=cancelctx>cancelCtx</h2><p>cancelCtx 顾名思义，是可被终止的 context，结构定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>cancelCtx</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Context</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mu</span>       <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>            <span style=color:#75715e>// protects following fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>done</span>     <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}         <span style=color:#75715e>// created lazily, closed by first cancel call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>children</span> <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>canceler</span>]<span style=color:#66d9ef>struct</span>{} <span style=color:#75715e>// set to nil by the first cancel call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>err</span>      <span style=color:#66d9ef>error</span>                 <span style=color:#75715e>// set to non-nil by the first cancel call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=canceler>canceler</h3><p>cancelCtx.children 是一个 set，key 的类型为 canceler，canceler 是所有可被<strong>直接</strong>终止的 context 所需要实现的接口，定义也很简单：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// A canceler is a context type that can be canceled directly. The
</span></span></span><span style=display:flex><span><span style=color:#75715e>// implementations are *cancelCtx and *timerCtx.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>canceler</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cancel</span>(<span style=color:#a6e22e>removeFromParent</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) <span style=color:#75715e>// 调用cancel()来终止
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Done</span>() <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{} <span style=color:#75715e>// 同 Context.Done
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=cancelctxvalue>cancelCtx.Value()</h3><p>cancelCtx.Value 对 cancelCtxKey 进行了特殊处理，参见 cancelCtxKey 的注释：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// &amp;cancelCtxKey is the key that a cancelCtx returns itself for.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>cancelCtxKey</span> <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><h2 id=withdeadline>WithDeadline()</h2><p>这是我们接触到的第二个派生新 context 的函数，我们先来看一眼签名：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithDeadline</span>(<span style=color:#a6e22e>parent</span> <span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>d</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>) (<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>CancelFunc</span>)
</span></span></code></pre></div><p>来试试看名说话，猜猜实现方法：</p><ol><li>接收一个 time.Time，名字又是 WithDeadline，想必是到了 d 指定的时间就终止 child<ul><li>这个定时终止的实现方法我觉得是开个定时器+用闭包终止，毕竟都引入 time 了，用定时器很方便</li><li>我最开始（只看函数名还没看入参类型时）的想法是开个 goro 自己终止，这显然也可以，定时器内部也是开 goro 的</li></ul></li><li>返回 Context+CancelFunc，按 WithCancel 的路子来推测的话，前者是 child，后者应该是用来提前手动终止 child 的<ul><li>这是不是也暗示 WithDeadline 内部会调用/参考 WithCancel</li><li>比如先 WithCancel 出 child 和 cancel() 来，然后开个定时器调用 cancel()</li></ul></li></ol><p>看看答案：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithDeadline</span>(<span style=color:#a6e22e>parent</span> <span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>d</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>) (<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>CancelFunc</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>parent</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;cannot create context from nil parent&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cur</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>parent</span>.<span style=color:#a6e22e>Deadline</span>(); <span style=color:#a6e22e>ok</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Before</span>(<span style=color:#a6e22e>d</span>) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The current deadline is already sooner than the new one.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>WithCancel</span>(<span style=color:#a6e22e>parent</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>timerCtx</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>cancelCtx</span>: <span style=color:#a6e22e>newCancelCtx</span>(<span style=color:#a6e22e>parent</span>),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>deadline</span>:  <span style=color:#a6e22e>d</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>propagateCancel</span>(<span style=color:#a6e22e>parent</span>, <span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dur</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Until</span>(<span style=color:#a6e22e>d</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dur</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>DeadlineExceeded</span>) <span style=color:#75715e>// deadline has already passed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>Canceled</span>) }
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>timer</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>AfterFunc</span>(<span style=color:#a6e22e>dur</span>, <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>DeadlineExceeded</span>)
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>Canceled</span>) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>处理流程：</p><ol><li>检查入参<ol><li>parent 是否为 nil</li><li>parent.Deadline() 是否比 d 还早<ul><li>如果比 d 还早，那就退化为 WithCancel(parent)</li></ul></li></ol></li><li>创建 child<ul><li>注意：这里用 newCancelCtx 包装了 parent</li><li>所以这里也调用了 propagateCancel，mark 一下</li><li>问题 1：为什么要包装 parent</li></ul></li><li>检查 d 是不是已经过了<ul><li>如果已经过了，那就终止掉 child，然后正常返回 child 和 cancelFunc</li><li>问题 2：为什么在这里才检查</li></ul></li><li>设置 c.timer<ul><li>问题 3：这里检查了 c.err==nil，为什么要检查，然后为什么检查的是 err 字段</li></ul></li></ol><p>答案（个人观点）：</p><ol><li>为了简化代码：Don&rsquo;t repeat yourself，包装 parent 来造一个 sidecar，这样就可以把 cancel 相关的逻辑交给 cancelCtx，不用 copy-paste 了<ul><li>用这种方法的话需要注意一下 child, parent 和 sidecar 之间的指向关系，推荐画个图</li></ul></li><li>为了逻辑的完整性与连贯性：这种情况不能回退，那就应该正常创建 child，所以此处需要先创建 child 再检查 d</li><li>c.err 是定义在 cancelCtx 中的，err!=nil 表示已经被终止，设置 timer 前检查是否已经被终止是为了避免重复终止（避免重复终止同一个 context 也是使用原则之一）；而检查是否终止其实是有多种方式的，检查 err 字段我认为是最简单的</li></ol><h2 id=timerctx>timerCtx</h2><p>看到这里的话，timerCtx 应该比较好理解了：组合了一个 cancelCtx，Context 的四个接口中委托出去三个，只重写了 Deadline()</p><p>不过 timerCtx 也是支持手动终止的，且手动终止 timerCtx 时需要关闭自己的 timer，所以重写了 cancel（这是 canceler 接口的函数），当然，细看 cancel 的话还能发现这里特别处理了 cancelCtx（前文提到的 sidecar，伏笔了）</p><h2 id=withtimeout>WithTimeout</h2><p>这个就很简单了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithTimeout</span>(<span style=color:#a6e22e>parent</span> <span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>timeout</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>) (<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>CancelFunc</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>WithDeadline</span>(<span style=color:#a6e22e>parent</span>, <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>().<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>timeout</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=withvalue>WithValue</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithValue</span>(<span style=color:#a6e22e>parent</span> <span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#a6e22e>Context</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>parent</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;cannot create context from nil parent&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>key</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;nil key&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>reflectlite</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>key</span>).<span style=color:#a6e22e>Comparable</span>() {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;key is not comparable&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>valueCtx</span>{<span style=color:#a6e22e>parent</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span>}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是给 context 加 value 的函数，这个函数同样会生成一个子 Context，流程也很简单，对三个入参进行检查，然后新建子 Context 并返回</p><h2 id=valuectx>valueCtx</h2><p>valueCtx 很有意思：长得像个 map，但实际上每个 valueCtx 只存一对 key-value，如果自己没搜到 key 的话就递归地往父 context 搜</p><p>关于这个特性的设计，我的理解是为了做 variable shadowing：这样就可以在不污染父 context 的 value map 的同时重写同名 key</p><p>其他地方就很简单直白了，因为只要管一对 key-value，所以也只需要实现 Value() 接口，其他的接口都委托给父 Context：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// A valueCtx carries a key-value pair. It implements Value for that key and
</span></span></span><span style=display:flex><span><span style=color:#75715e>// delegates all other calls to the embedded Context.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>valueCtx</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Context</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>interface</span>{}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>valueCtx</span>) <span style=color:#a6e22e>String</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>contextName</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Context</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;.WithValue(type &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>reflectlite</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>key</span>).<span style=color:#a6e22e>String</span>() <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;, val &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>val</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;)&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>valueCtx</span>) <span style=color:#a6e22e>Value</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>interface</span>{} {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>key</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>key</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Context</span>.<span style=color:#a6e22e>Value</span>(<span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>String() 接口是 stringer 的接口，大家很熟悉就不作展开了</p><h1 id=总结>总结</h1><p>五百多行的小包写得很漂亮，作为一个网络的基础包，做到了足够精简，同时也提供了拓展性默认提供的四种实现（emptyCtx cancelCtx timerCtx valueCtx）覆盖了</p></section><footer class=post-tags><a href=http://chiro.wang/tags/tech>tech</a>
<a href=http://chiro.wang/tags/go>go</a></footer><nav class=post-nav><a class=prev href=http://chiro.wang/posts/midnight-in-shenzhen/><span>←</span><span>Midnight in Shenzhen</span></a>
<a class=next href=http://chiro.wang/posts/hello-hugo/><span>Hello Hugo</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2022 <a href=http://chiro.wang/>Twilight Tornado</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>